-- 1. Create cart_sessions table
CREATE TABLE IF NOT EXISTS public.cart_sessions (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  session_token text NOT NULL UNIQUE,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- 2. Create cart_items table
CREATE TABLE IF NOT EXISTS public.cart_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id uuid REFERENCES public.cart_sessions(id) ON DELETE CASCADE,
  sku_id bigint NOT NULL,
  variation_id bigint NOT NULL,
  quantity int NOT NULL DEFAULT 1,
  
  -- Validation: Only allow 'reserved' or 'waitlist'
  status text NOT NULL CHECK (status IN ('reserved', 'waitlist')),
  
  expires_at timestamptz,
  created_at timestamptz DEFAULT now(),
  
  -- Prevent duplicates per session+variation
  UNIQUE(session_id, variation_id)
);

-- 3. Indexes for performance
CREATE INDEX IF NOT EXISTS idx_cart_items_variation_status 
  ON public.cart_items (variation_id, status);

CREATE INDEX IF NOT EXISTS idx_cart_items_session 
  ON public.cart_items (session_id);

-- 4. Enable RLS (Security)
ALTER TABLE public.cart_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;

-- 5. Grant Permissions with RLS Policies
-- Allow anyone (anon) to create a session if they have the token (handled by RPC mostly, but good for read)
-- For simplicity with RPC 'SECURITY DEFINER', we can leave RLS open or rely on the function permissions.
-- If the function is NOT Security Definer, we need to grant access:

GRANT ALL ON public.cart_sessions TO anon, authenticated, service_role;
GRANT ALL ON public.cart_items TO anon, authenticated, service_role;

-- Policies (Optional, but recommended if accessing directly from client)
-- CREATE POLICY "Allow public access" ON public.cart_sessions FOR ALL USING (true);
-- CREATE POLICY "Allow public access" ON public.cart_items FOR ALL USING (true);

-- 6. RPC Function: add_to_cart (As discussed)
create or replace function add_to_cart(
  p_session_token text,
  p_sku_id bigint,
  p_variation_id bigint,
  p_qty int
)
returns json
language plpgsql
security definer -- Bypass RLS so we can manage stock safely
as $$
declare
  v_session_id uuid;
  v_quota int;
  v_sold_count int;
  v_active_reserved int;
  v_available_stock int;
  v_current_qty int;
  v_current_status text;
  v_new_status text;
  v_expires_at timestamp with time zone;
begin
  -- 1. GET OR CREATE SESSION
  insert into public.cart_sessions (session_token)
  values (p_session_token)
  on conflict (session_token) do update 
  set updated_at = now()
  returning id into v_session_id;

  -- 2. LAZY CLEANUP
  delete from public.cart_items 
  where variation_id = p_variation_id 
  and status = 'reserved' 
  and expires_at < now();

  -- 3. LOCK & GET QUOTA
  select reels_quota into v_quota
  from public."SKU_variations"
  where id = p_variation_id
  for update;

  v_quota := coalesce(v_quota, 0);

  -- 4. GET CURRENT HOLDING
  select quantity, status into v_current_qty, v_current_status
  from public.cart_items
  where session_id = v_session_id and variation_id = p_variation_id;
  
  v_current_qty := coalesce(v_current_qty, 0);

  -- 5. CALCULATE AVAILABILITY
  select 
    (select count(*) from public.reels_orders where variation_id = p_variation_id and status in ('paid', 'pending_payment')),
    (select coalesce(sum(quantity), 0) from public.cart_items where variation_id = p_variation_id and status = 'reserved' and expires_at > now())
  into v_sold_count, v_active_reserved;

  v_available_stock := v_quota - v_sold_count - v_active_reserved;

  if v_available_stock >= p_qty then
    v_new_status := 'reserved';
    v_expires_at := now() + interval '60 minutes'; -- 60 min timer
  else
    if v_current_status = 'reserved' then
       return json_build_object(
          'success', false,
          'message', 'Not enough stock to add more.',
          'status', v_current_status
       );
    else 
       v_new_status := 'waitlist';
       v_expires_at := null;
    end if;
  end if;

  -- 6. UPDATE CART
  insert into public.cart_items (
    session_id, sku_id, variation_id, quantity, status, expires_at
  )
  values (
    v_session_id, p_sku_id, p_variation_id, p_qty, v_new_status, v_expires_at
  )
  on conflict (session_id, variation_id) 
  do update set
    quantity = public.cart_items.quantity + p_qty,
    status = v_new_status, 
    expires_at = v_expires_at;

  -- 7. RETURN
  return json_build_object(
    'success', true,
    'status', v_new_status,
    'expires_at', v_expires_at
  );
end;
$$;


-- 7. RPC Function: submit_cart_to_reels_order
-- Transforms cart items into actual orders
create or replace function submit_cart_to_reels_order(
  p_session_token text,
  p_customer_name text,
  p_whatsapp text
)
returns json
language plpgsql
security definer
as $$
declare
  v_session_id uuid;
  v_item record;
  v_order_id bigint;
  v_orders json[] := '{}';
begin
  -- 1. Get Session
  select id into v_session_id from public.cart_sessions where session_token = p_session_token;
  if v_session_id is null then
     return json_build_object('success', false, 'message', 'Session not found');
  end if;

  -- 2. Process Reserved Items
  -- We only process 'reserved' items that haven't expired. 
  -- Optionally verify stock again if paranoid, but reservation guarantees it for the duration.
  
  for v_item in 
    select * from public.cart_items 
    where session_id = v_session_id 
    and status = 'reserved'
    and (expires_at > now() or expires_at is null) -- Reserved items usually have expiry, but just in case
  loop
      -- Create Order
      insert into public.reels_orders (
         customer_name,
         whatsapp,
         sku_id,
         variation_id,
         status,
         qty, -- Assuming you have logic for multiple qty, or assuming 1 per row for now? Model usually is 1 row per order or line items.
         -- If reels_orders is 1-order-per-item structure based on registerReelsOrder logic:
         submission_time
      ) values (
         p_customer_name,
         p_whatsapp,
         v_item.sku_id,
         v_item.variation_id,
         'pending_payment', -- Initial status
         v_item.quantity,
         now()
      ) returning id into v_order_id;
      
      -- Add to result
      v_orders := array_append(v_orders, json_build_object('order_id', v_order_id, 'sku_id', v_item.sku_id));
      
      -- Remove from cart
      delete from public.cart_items where id = v_item.id;
      
  end loop;

  -- Returns list of created orders
  return json_build_object(
    'success', true,
    'orders', v_orders
  );
end;
$$;
